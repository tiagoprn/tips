* CRIAR UM FILESYSTEM UDF (Universal Disk Format, usado em DVDs e discos óticos no geral):
    $ dd if=/dev/zero of=/dev/sdc bs=1M count=1
    $ mkudffs -b 512 --media-type=hd /dev/sdc

* CHROOT NO SYSTEMRESCUECD:
  * Preparar o binding no chroot:
    $ mount --bind /dev <chroot dir>/dev
    $ mount --bind /proc <chroot dir>/proc
    $ mount --bind /sys <chroot dir>/sys

  * Como fazer chroot no SystemRescueCD:
    $ SHELL=/bin/bash chroot <ponto_de_montagem>
    OU
    $ exec bash
    $ chroot /mnt/<mountpoint> /bin/bash

* Como bootar o Arch Linux no GRUB2 (modo de edição "e"):
    set root=(hd0,0)
    linux /boot/vmlinuz26 root=/dev/sda1 ro
    initrd /boot/kernel26.img
    boot

* 2 formas de ver se uma porta está ativa no linux (por exemplo, a porta 9000 do php5-fpm):
    $ netstat -apn | grep ':9000'
    $ lsof -i tcp:9000 -n

* Bootar um pendrive bootável ou iso pelo qemu:
    $ qemu-system-x86_64 -hda /dev/sdx
    $ qemu-system-x86_64 -cdrom filename.iso


* Total de linhas de um arquivo:
    $ wc -l [nome_arquivo]


* Substituir todas as vírgulas em um arquivo com uma linha grande por quebras de linha:
    $ cat query_demorada_ids.txt | sed 's/\,/\n/g' > query_demorada_formatted.txt

* Exportar um dicionário do programa aspell para arquivo:
  aspell --encoding UTF-8 -l pt_BR dump master > /tmp/brasil.txt
  (claro que, neste caso, tenho que ter o dicionário pt_BR instalado no sistema para funcionar)

* Descobrir a versão da Distro:
    $ cat /etc/issue

* Testar se a resolução de nomes (DNS) está funcionando na máquina:
  $ dig [nome_do_dominio]
  (se não estiver resolvendo os DNS não vai retornar nada)

* Como fazer uma máquina responder por vários IPs:
    Após subir a interface "eth0" , ou equivalente:
        #multi_ips.sh
        #!/bin/bash
        ifconfig eth0:0 165.1.200.237 netmask 255.255.254.0
        ifconfig eth0:1 165.1.200.238 netmask 255.255.254.0
        ifconfig eth0:2 165.1.200.239 netmask 255.255.254.0
        ifconfig eth0:3 165.1.200.240 netmask 255.255.254.0
        ifconfig eth0:4 165.1.200.241 netmask 255.255.254.0
        ifconfig eth0:5 165.1.200.242 netmask 255.255.254.0
        ifconfig eth0:6 165.1.200.243 netmask 255.255.254.0
        ifconfig eth0:7 165.1.200.244 netmask 255.255.254.0
        ifconfig eth0:8 165.1.200.245 netmask 255.255.254.0
        ifconfig eth0:9 165.1.200.246 netmask 255.255.254.0
        ifconfig eth0:10 165.1.200.247 netmask 255.255.254.0
        ifconfig eth0:11 165.1.200.248 netmask 255.255.254.0
        ifconfig eth0:12 165.1.200.249 netmask 255.255.254.0
        ifconfig eth0:13 165.1.200.250 netmask 255.255.254.0
        ifconfig eth0:14 165.1.200.251 netmask 255.255.254.0
        ifconfig eth0:15 165.1.200.252 netmask 255.255.254.0
        ifconfig eth0:16 165.1.200.253 netmask 255.255.254.0
        ifconfig eth0:17 165.1.200.254 netmask 255.255.254.0
        ifconfig eth0:18 165.1.200.132 netmask 255.255.254.0
        IMPORTANTE: É melhor colocar os IPs de eth0:0 até o último em um range de IPs diferente do ip que está na eth0 principal.
    Para confirmar, após setar os IPs, execute:
        # ifconfig -a
    Posso colocar esse script "multi_ips.sh" no meu /etc/rc.local, por exemplo.

    ALTERNATIVE WAY: EDIT THE IPs CONFIGURATION FILE:

        $ vim /etc/network/interfaces:

            # The loopback network interface
            auto lo
            iface lo inet loopback

            # The main network interface (in this case, as DHCP IP)
            auto eth0
            iface eth0 inet dhcp

            # The main network interface (as STATIC IPs)
            auto eth0:0
            iface eth0:0 inet static
            address 192.168.0.1
            netmask 255.255.255.0
            broadcast 192.168.0.255

            auto eth0:1
            iface eth0:1 inet static
            address 192.168.0.2
            netmask 255.255.255.0
            broadcast 192.168.0.255

            auto eth0:2
            iface eth0:2 inet static
            address 192.168.0.3
            netmask 255.255.255.0
            broadcast 192.168.0.255

* Exemplo de uso simples do rsync:
    /*
    PARÂMETROS DO RSYNC:
      r: recursivo
      c: usa checksum para detectar se um arquivo mudou
      h: saída human readable
      z: compress data durante a transferência
      P: continua de onde parou (partial)
      v: verboso
      i: informaçoes detalhadas do que ser feito com o arquivo
      progress: mostra o progresso da transferência
      iconv: codificação de origem e destino dos arquivos. Ex.: latin1,utf8
      log_file: nome do arquivo que guarda o log das operações que foram feitas
      delete: deleta os arquivos para manter a origem e o destino sincronizados
      bwlimit: máximo da banda a ser usada, em kbps
      IMPORTANTE:
        --dry-run : simulação da transferência, mas não transfere nada fisicamente (útil para ver o que seria feito - DEBUG)
     */
    rsync -rchzPvi --bwlimit=300 --progress --iconv=latin1,utf8 --log-file=log.txt --delete  projetos_tiagoprn/* projetos_tiagoprn_ALL
    /* Abaixo, desconsidera as pastas e arquivos com .svn e .git no nome. */
    rsync -rchzPvi --bwlimit=300 --progress --iconv=latin1,utf8 --log-file=sync.txt --delete --exclude '.svn*' --exclude '.git*' /origin/* /destiny/folder

    /* Abaixo, faz o rsync para um servidor remoto, via ssh, em um server que ouve a conexão ssh em uma porta diferente da 22000 */
    rsync -rchzPvi --bwlimit=100 --progress --iconv=latin1,utf8 --log-file=/tmp/rsync.txt --delete --exclude '*~' --exclude '*.BAK' /origem/* -e "ssh -p 22000" user@remoteserver.net:/destino

    RSYNC COMO DAEMON: http://kezhong.wordpress.com/2010/12/01/rsync-backup-in-daemon-mode/

    RSYNC WITH EXCLUDE FILE:
        EXCLUDE_FILE
            /dev/*
            /proc/*
            /sys/*
            /media/*
            /mnt/*
            /run/*
            /tmp/*
        rsync -avc --exclude-from=EXCLUDE_FILE / /mnt




* Exemplo de grep com match antes do primeiro pipe e não match após:
    $ grep -rn 'string_to_find' . | grep -v 'cache' | grep -v '.svn'
    Neste exemplo, ele vai procurar 'string_to_find' recursivamente na pasta mostrando o número das linhas onde a string foi encontrada, mas vai ignorar os resultados onde ele encontrar as strings "cache" e ".svn".

* Exemplo de wget recursivo para navegar offline:

    $ wget -k -r -p http://www.site.com

The -r option recurses through the site's links starting at http://www.site.com/index.html. The -k option rewrites the downloaded files so that links from page to page are all relative, allowing you to navigate correctly through the downloaded pages. The -p option downloads all extra content on the page, such as images. This way, you can get a mirror of a site on your desktop. wget also handles proxies, cookies and HTTP authentication, along with many other conditions.

* reference: http://tech.gaeatimes.com/index.php/archive/how-to-use-wget-through-proxy :

Wget is a super-useful utility to download pages and automate all types of web related tasks. It works for HTTP as well as FTP URLâs. Here is a brief tutorial on how to use wget through proxy server.

To get wget to use a proxy, you must set up an environment variable before using wget. Type this at the command prompt / console:
For Windows:
set http_proxy=http://proxy.example.com:8080

For Linux/Unix:
export http_proxy="http://proxy.example.com:8080"

Replace proxy.example.com with your actual proxy server.
Replace 8080 with your actual proxy server port.

You can similarly use ftp_proxy to proxy ftp requests. An example on Linux would be:
export ftp_proxy="http://proxy.example.com:8080"

Then you should specify the following option in wget command line to turn the proxy behavior on:
âproxy=on

Alternatively you can use the following to turn it off:
âproxy=off

You can use âproxy-username="user name" âproxy-passwd="password" to set proxy user name and password where required.
Replace user name with your proxy server user name and password with your proxy server password. Another alternative is to specify them in http_proxy / ftp_proxy environment variable as follows:
export http_proxy="http://username:password@proxy.example.com:8080"


* GPG:
    Encriptar:
        $ gpg -r B47B5D91 -se encriptar.txt
    Decriptar:
        $ gpg -d encriptado.gpg > encriptado.txt
(cheatsheet: http://irtfweb.ifa.hawaii.edu/~lockhart/gpg/)

* Scripts no cron:

    $ crontab -e

    59 23 * * * /home/tiago/script.sh > /home/tiago/script.log 2>&1

    OBS.: the '2>&1' parameters indicates that the standard error (2>) é redirecionado para o mesmo arquivo apontado pela saída padrão (&1) --- ou seja, a saída padrão e os erros do script estarão em /home/tiago/script.log.
OBS2.: Os logs de execução dos scripts que estão no cron (ou seja, do próprio cron), estão em /var/log/cron.

* Criação de usuários:

    $ useradd -m -d /home/newuser newuser

* Mudar o shell de um usuário:
    - Logar como o usuário desejado;
    - Rodar o comando chsh passando o caminho do shell.
        Ex.:
            $ chsh -s /bin/bash

* To get 2Gb of space for files in RAM, edit /etc/fstab to add the following line:
    tmpfs     /var/ramspace       tmpfs     defaults,size=2048M     0     0
    After that, /var/ramspace is now the place to store your files in memory.

* Equivalente ao baobab, em modo texto (dialog):
    ncdu

* crontab configuration sample:

# Minute   Hour   Day of Month       Month          Day of Week        Command
# (0-59)  (0-23)     (1-31)    (1-12 or Jan-Dec)  (0-6 or Sun-Sat)
0        5          *             *                *            /home/user/my_command.sh

* COPY A SSH KEY TO ANOTHER SERVER:
    $ ssh-copy-id -i ~/.ssh/id_rsa.pub -p [remote_ssh_port] remoteuser@192.168.0.200

* Current user UID / GID:

    $ id

    Sample output:

    uid=1000(tiago) gid=1000(tiago) grupos=1000(tiago),0(root),10(wheel),100(users),108(vboxusers),142(docker)
